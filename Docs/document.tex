\documentclass{article}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{Progetto finale di Reti Logiche - A.A. 2019/2020}
\rhead{Weger Marco}
\cfoot{\thepage}

\usepackage{tikz} % Import the tikz package
\usetikzlibrary{automata} % Import library for drawing automata
\usetikzlibrary{positioning} % ...positioning nodes
\usetikzlibrary{arrows} % ...customizing arrows

\usepackage{float}
\usepackage{amsmath}

\tikzset{
->, % makes the edges directed
node distance=3cm, % specifies the minimum distance between two nodes. Change if necessary.
every state/.style={thick, fill=gray!10}, % sets the properties for each ’state’ node
initial text=$ $, % sets the text that appears on the start arrow
}

\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}

\usepackage[italian]{babel}

\addto\captionsitalian{
  \renewcommand{\contentsname}
    {Contenuto}
}

\usepackage{graphicx}

\begin{document}
\pagenumbering{gobble}
\title{Progetto finale di Reti Logiche}
\author{Weger Marco - Matricola n° 888201}
\date{Anno Accademico 2019/2020}
\maketitle

\tableofcontents

\newpage
\pagenumbering{arabic}
\section{Introduzione}
Per questo progetto mi sono posto l'obiettivo di descrivere un componente che rispetti le specifiche sia in pre sintesi che in post sintesi.
Ho voluto scrivere del codice di facile lettura e che si adatti in modo semplice e rapido a qualsiasi tipo di modifica del pattern e/o della dimensione della memoria e del suo contenuto (più dettagli in seguito).
La FPGA consigliata non ci pone particolari vincoli di area nonostante ciò ho voluto dare particolare riguardo sia ai tempi di esecuzione che all'area occupata.
Per quanto riguarda la frequenza di clock non sono andato alla ricerca di una massimizzazione in quanto la specifica fissa il periodo di clock a 100 ns.
\subsection{Obiettivi aggiuntivi}
Dopo essermi assicurato di rispettate le richieste della specifica fornita mi sono posto i seguenti obiettivi:
\begin{enumerate}
	\item Minimizzare il tempo trascorso dal momento che il segnale di start viene ricevuto al momento di invio del segnale di done;
	\item Disattivare il segnale di enable della memoria tra le varie esecuzioni;
	\item Descrivere un componente in grado di funzionare anche nel caso ci fossero reset asincroni durante l'esecuzione di una codifica;
	\item Rendere il componente adattabile ad un'eventuale modifica della lunghezza dell'indirizzo della cella di memoria tramite una costante;
	\item Rendere il componente adattabile ad un'eventuale modifica della dimensione di una singola cella di memoria tramite una costante (ADDR);
	\item Rendere il componente adattabile ad un'eventuale modifica del numero di elementi in una working-zone tramite una costante (WZ\textunderscore OFFSET);
	\item Rendere il componente adattabile ad un'eventuale modifica del numero di working-zone tramite una costante (WZ\textunderscore NUM).
\end{enumerate}

Al fine di raggiungere i sopracitati obiettivi ho assunto che l'indirizzo da codificare e l'indirizzo codificato vengano sempre salvati in successione in celle immediatamente consecutive all'ultimo indirizzo di working-zone (es. se ci fosse 16 working-zone RAM(16) conterrebbe l'indirizzo da codificare e RAM(17) l'indirizzo codificato).
Tutte le ottimizzazioni descritte in seguito sono state valutate sulla base dei dati forniti dalla specifica e non tengono conto dell'eventuale crescita sproposita delle costanti sopracitate.
\subsection{Obiettivo velocità}
La limitazione più stringente in termini di velocità è data dall'accesso alla RAM e dai suoi ritardi. Al fine di minimizzare i tempi di letture e confronti ho optato per un componente che al momento della lettura di un dato imposti contemporaneamente la successiva richiesta. In questo modo posso garantire l'esecuzione dei confronti tra l'indirizzo e le N working-zone in N+1 cicli di clock. Occorreranno poi 2 cicli di clock per la scrittura del dato codificato in memoria e la notificazione di elaborazione completata. Un ulteriorie ciclo di clock mi è servito a garantire che il segnale \textit{o\textunderscore mem} non rimanesse attivo tra un'esecuzione e la successiva.
Ricapitolando, nel caso pessimo in cui l'indirizzo letto non si trova in nessuna delle work-zone
\begin{equation*}
T_\mathrm{esecuzione} = (N+1) \cdot T_\mathrm{clock}+3 \cdot T_\mathrm{clock}
\end{equation*}
Nella valutazione del tempo di esecuzione va preso in considerazione il fatto che il segnale di start potrebbe arrivare sul fronte di discesa del clock, qualora succedesse l'esecuzione ritarderà di $T_\mathrm{clock}/2$.
Nella specifica forntia l'esecuzione massima durerà 1200 ns (nel caso in cui \textit{i\textunderscore start} fosse allineato al fronte di salita del clock), 1250 ns altrimenti.
\subsection{Obiettivo codice semplice e riutilizzabile}
Da scrivere...
\subsection{Funzionamento in sintesi}
Una soluzione che memorizza tramite registri i valori delle working-zone non avrebbe migliorato in modo significativo i tempi di esecuzione peggiorando però l'area occupata pertando ho optato per la  in memoria a ogni esecuzione.
La singola esecuzione di una codifica può essere descritta attraverso un numero finito di step (che poi diventeranno una macchina a stati finiti):
\begin{enumerate}
	\item Reset ed attesa del segnale di start (\textit{i\textunderscore start=1});
	\item Abilitazione della memoria e richiesta dell'indirizo da codificare (salvato in un registro);
	\item Richiesta della i-esima working-zone e confronto con l'indirizzo salvato, eventuale codifica e passaggio a step successivo (passo ripetuto per i compreso tra 0 e il numero di working-zone);
	\item Scrittura dell'indirizzo codificato in memoria;
	\item Invio segnale di elaborazione completata (\textit{o\textunderscore done=1}) e attesa feedback (\textit{i\textunderscore start=0}), il dato è disponibile fin dal momento in cui \textit{o\textunderscore done} viene portato a 1;
\end{enumerate}
\subsection{Note aggiuntive sulla specifica}
Per la sintesi è stata scelta l'FPGA xc7a200tfbg484-1.

\noindent\rule{\textwidth}{1pt}
\newpage
\section{Architettura}
\subsection{Macchina a stati finiti}
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
\begin{figure}[H]
\centering % centers the figure
\begin{tikzpicture}
%RST,EN_MEM,GET_ADDR,WZ,W_MEM,DONE);
\node[state, initial, minimum size=1.8cm] (RST)  at (0,3) {$RST$};
\node[state, minimum size=1.8cm] (MEM) at (5,3) {$MEM$};
\node[state, minimum size=1.8cm] (ADDR) at (10,3) {$ADDR$};
\node[state, minimum size=1.8cm] (WZ) at (10,0) {$WZ$};
\node[state, minimum size=1.8cm] (WRITE) at (5,0) {$WRITE$};
\node[state, accepting, minimum size=1.8cm] (DONE) at (0,0) {$DONE$};
\draw (RST) edge (MEM);
\draw (MEM) edge (ADDR);
\draw (ADDR) edge (WZ);
\draw (WZ) edge node [midway, below] {ADDR in WZ} node[above, midway] {last WZ checked} (WRITE);
\draw (WRITE) edge (DONE);
\draw (DONE) edge (RST);
\draw (WZ) edge[loop right] node {others} (WZ);
%{ADDR in WZ or LAST WZ checked}
\end{tikzpicture}
\caption{macchina a stati finiti implementata.}
\label{fig:my_label}
\end{figure}
\begin{table}[H]
\centering
\begin{tabular}{|c|c|}
\hline
Stato & Descrizione \\ \hline\hline
RST &             \\ \hline
MEM &             \\ \hline
ADDR &             \\ \hline
WZ &             \\ \hline
WRITE &             \\ \hline
DONE &             \\ \hline
\end{tabular}
\caption{stati della macchina a stati finiti implementata.}
\end{table}
\section{Sintesi}
\section{Simulazioni}
\section{Conclusione}

\end{document}
